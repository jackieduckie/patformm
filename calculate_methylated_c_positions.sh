#!/bin/bash
# Script: calculate_methylated_c_positions.sh
# Author: Ruining Dong
# Date: 2024-06-26
# Summary: This script processes an input BED file to calculate the positions of methylated 'C's 
# based on the MM tag, converts them to CpG index values using wgbstools, and handles invalid genomic regions.
# input bed is generated by another script: patformm


# mamba activate methyl_env
source /g/data/pq08/software/mambaforge/etc/profile.d/conda.sh
conda activate /g/data/pq08/software/mambaforge/envs/methyl_env
module load samtools

# Function to display usage information
usage() {
    echo "Usage: $0 [--threads <threads>] [-o <output_file>] <input_bed_file>"
    exit 1
}

# Default number of threads
THREADS=1
OUTPUT_FILE=""

# Parse the command-line arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --threads)
            THREADS=$2
            shift
            ;;
        -o)
            OUTPUT_FILE=$2
            shift
            ;;
        *)
            if [[ -z "$INPUT_BED" ]]; then
                INPUT_BED=$1
            else
                usage
            fi
            ;;
    esac
    shift
done

# Check if the input BED file is provided
if [[ -z "$INPUT_BED" ]]; then
    usage
fi

# Function to calculate the positions of methylated Cs
calculate_positions() {
    local chrom=$1
    local start=$2
    local end=$3
    local cpg_start=$4
    local cpg_end=$5
    local mm_tag=$6

    # Extract the sequence using samtools faidx. remove new line so that sequence is in one line.
    sequence=$(samtools faidx GRCh38Decoy.fa ${chrom}:${start}-${end} | grep -v ">" | tr -d '\n')
    
    # Extract the t values from the MM tag
    t_values=$(echo $mm_tag | grep -oP 'MM:Z:C\+C.+' | tr ',;' ' ')
    
    if [ -z "$t_values" ]; then
        echo -e "$chrom\t$start\t$end\tNo methylated C positions found"
        return
    fi

    # Split t values into an array and remove the first value
    t_values_array=($t_values)
    t_values_array=("${t_values_array[@]:1}")
    
    if [ ${#t_values_array[@]} -eq 0 ]; then
        echo -e "$chrom\t$start\t$end\t$mm_tag\t$cpg_start\t$cpg_end\tNA\tNA"
	# output the pat format
        # echo -e "$chrom\t$cpg_start\tNA"
        return
    fi

    # Find the positions of all 'C' in the sequence
    c_positions=()
    for (( i=0; i<${#sequence}; i++ )); do
        if [ "${sequence:$i:1}" == "C" ]; then
            c_positions+=($((start + i)))
        fi
    done
    # echo -e "$chrom\t$start\t$end\t$mm_tag\t${c_positions[@]}"
    
    # Calculate the positions of the methylated 'C's
    methylated_c_positions=()
    sum_t=0
    for t in "${t_values_array[@]}"; do
        sum_t=$((sum_t + t + 1))
        if [ $sum_t -le ${#c_positions[@]} ]; then
            methylated_c_positions+=(${c_positions[$((sum_t - 1))]})
        else
            break
        fi
    done
    # echo -e "Methylated C positions: $chrom\t$start\t$end\t$mm_tag\t$cpg_start\t$cpg_end\t${methylated_c_positions[@]}"

    # Convert methylated C positions to CpG index values using wgbstools
    # Redirect error message if the genomic position has no valid CpG index.
    # Ran into this error with text_xyz bam: chr1	126047	126196	1238	1239	MM:Z:C+C.,7,1;
    cpg_indexes=()
    for pos in "${methylated_c_positions[@]}"; do
        if [ "$pos" == "NA" ]; then
            cpg_indexes+=("NA")
        else
            cpg_index=$(wgbstools convert -r "${chrom}:${pos}" 2>/dev/null | grep -oP '(?<=: )[0-9]+')
            if [ -n "$cpg_index" ]; then
	        cpg_indexes+=($cpg_index)
	    # else
	        # cpg_indexes+=("NA")
	    fi
        fi
    done
    
    # echo -e "$chrom\t$start\t$end\t$mm_tag\t$cpg_start\t$cpg_end\t${cpg_indexes[@]}"

    # Generate CpG index string and calculate start and end indexes
    # methylated_cpg_index_string=$(printf "%s " "${cpg_indexes[@]}" | sed 's/ $//')

    # Generate the methylation string
    # The spaces are included in the evaluation if [[ " ${cpg_indexes[@]} " =~ " $i " ]] to ensure that we match entire words (CpG indexes) and avoid partial matches.
    methylation_string=""
    for (( i=cpg_start; i<cpg_end; i++ )); do
        if [[ " ${cpg_indexes[@]} " =~ " $i " ]]; then
            methylation_string+="C"
        else
            methylation_string+="T"
        fi
    done

    echo -e "$chrom\t$start\t$end\t$mm_tag\t$cpg_start\t$cpg_end\t${cpg_indexes[@]}\t$methylation_string"

}
export -f calculate_positions

# Run the calculate_positions function in parallel
# if [[ -z "$OUTPUT_FILE" ]]; then
#     cat $INPUT_BED | parallel -j $THREADS -k --colsep '\t' calculate_positions {1} {2} {3} {6}
# else
#     cat $INPUT_BED | parallel -j $THREADS -k --colsep '\t' calculate_positions {1} {2} {3} {6} > $OUTPUT_FILE
# fi

# Read the input BED file line by line
# tmp_file=$(mktemp)
tmp_file=tmp.out
while IFS=$'\t' read -r chrom start end cpg_start cpg_end mm_tag; do
    calculate_positions $chrom $start $end "$cpg_start" "$cpg_end" "$mm_tag"
done < $INPUT_BED > $tmp_file
    # Generate pat format fields
    # echo -e "$chrom\t$cpg_start\t$methylation_string"

if [[ -z "$OUTPUT_FILE" ]]; then
    awk -F'\t' '$8 != "NA" {print $1"\t"$5"\t"$8}' $tmp_file | sort -k2,2n -k3,3 | uniq -c | awk '{print $2"\t"$3"\t"$4"\t"$1}'
else
    awk -F'\t' '$8 != "NA" {print $1"\t"$5"\t"$8}' $tmp_file | sort -k2,2n -k3,3 | uniq -c | awk '{print $2"\t"$3"\t"$4"\t"$1}' > $OUTPUT_FILE
fi
# rm $tmp_file
